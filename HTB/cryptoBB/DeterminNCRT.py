from functools import reduce
import math
import binascii
import sys




ct1 = int("A1EE67508518CDDCE9D986BA5BB6AC9F8660D2B5BBC17A4ACE1BD7D842B0B5B406FA3308760DF9E109DD812C0BD26CE7929AC9FA1BF722E06ABD6944BDFB6C1BA22C6E3384277287862E636C295A9766B2434DA42C0225D7BB0FCB5041EE5689B3C2C65678DC9FE961990FE2A1429B2166280808F009C483AE0A7B6D6B7657EE", 16)  
n1 = int("BB01DE054B3379C99105D03657074C50EAAD5CA8E29417640547D253197037A7A82FDF9B8C5049E48D53A88191D70515BE9D2DD3B08B9B8A5586CBD03DB8E16B884B3CEBB79C44A0B702CA0198D663CABE24D06EB31FFF953442C5C27D0D97F3E0826782F04C66984755476E50CE153E0D3C3195E3E8F7AA8CEA7C642F1B1EF9", 16) 
pub1 = 5



ct2 = int("4263CB968767D9F504627DD89C1F7A0C05D7295BA06BE05D3FABB08CC50C8B1A96CF916F6985AB494094F95A1FBC64A3B2EE74FD30FCF9D4054D9FA81107E2373C89C4E272A4453FF109EDCB4747025414087FC1991E41BF9D8D8AE620F0D4828DDCF211BDBF62681F5DBBA3C7C6ABDE39843D0B832667A2077246F7EBD66DA5", 16) 
n2 = int("5CB324B8B9CD79C4A2C61677DA1AC5D6979F701EAE325C8B809E08D1BE41687AC72207D8BA509231D8A2C1391CFAE2B2904B740C02AFE0932B62A57E066B48CBC453F0760FD4DAA009A40474773388E762027E99E2AAD1728669A42B1FB953EF2DBC5FF3E366E5A616E3F5E5FB62FEB86C629C6C5C3D4186C081EAE1D7EA4677", 16) 
pub2 = 5


ct3 = int("4850718068FC19D2A5525FF4B32C8CA1D89052665B2DC6517D6A406791BDAE1661975DE23139B60984119E0915EEE82328F8373A131022574793ECFE431386724D5057011BCF699BF5281CE782E7F01FB201FFC8BC02D9097CD58936309DA35EB32CF5791960370C8C315016514123A395A549FCD7B84C3157F94DF9F72DABD3", 16) 
n3 = int("7BF60D6FB4E8CCB84E7921BAEC2A4532F45F8FBEB01C98427086A8839AE2993A99C79BB64F6724B23B60004AEA8463B71D9DCD7EE1BA6870DF807BA01118204FF5369D1B2AFAB336FAC68B394B83BC76B75E6F5A7D06EB6F3E3490223A9B3763198C5730E77EB80BFFBF086F8B284538277E28E1BB58AC56D5717C5FDA18466B", 16) 
pub3 = 5

modn = [n1,n2,n3]
encryptedMessage = [ct1,ct2,ct3]

def chinese_remainder(n, a):
    sum = 0
    prod = reduce(lambda a, b: a*b, n)
 
    for n_i, a_i in zip(n, a):
        p = prod // n_i
        sum += a_i * mul_inv(p, n_i) * p
    return sum % prod
 
def mul_inv(a, b):
    b0 = b
    x0, x1 = 0, 1
    if b == 1: return 1

    while a > 1:
	    try:
        	q = a // b
        	a, b = b, a%b
        	x0, x1 = x1 - q * x0, x0
	    except:
		    print("Bad N values (check no common factors in N vals)")
		    return 0
    if x1 < 0: x1 += b0
    return x1
 
def gcd(L):
    return reduce(math.gcd, L)

n = modn
a = encryptedMessage
g = gcd(modn)
print("GCD of N values: "+ str(g))
if (g>1):
    print("Cannot compute - check your N values for a common factor")
else:
    print("Result (x) is: "+str(chinese_remainder(n, a))+"\n")
    count=0
    for str1 in modn:
        print("x mod "+str(str1)+"="+str(encryptedMessage[count]))
        count=count+1