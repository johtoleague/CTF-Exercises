import binascii
message = binascii.unhexlify("8ECB5CDED9D90CD114A0F9F48F47AD7F53C83B0C3A1C45043876940D97BAB4B72A8751439ED1647CB0A9C6600646C56B38B21390FB8757885984ECE9850923263E0008A91F68FAFFAF55527C529A72974B256565EFE9D50AC9B80BB1DA03C031BC1ED652C9A3D3FD8A31CC797E695D1DD4A5CEC67BBB6FCED2A393E71E4ABC67")
mod_n = "E06D234E8EC8BA4C550760939DCF2F55B7B5DC428FE0957067277BD69521B6F094A4A21AFE6D6DADEEF0E7D57A69656C87E2308A91208E37C2457B4AC703877200A70478C4D463ACAC896B6E39B0D2C5E6CC558D73A689C19F19919DA99DCFDE2917A266E0E515A03D0CEE13B653DF979B354D0DC43688993F01185FCE01AF19"
public_key = "5"


# Python 3.6
from functools import reduce
def chinese_remainder(n, a):
    sum = 0
    if isinstance(a, bytes):
        # unpack the bytes from a, and assign it back to as an an integer
        a = a.decode()

    prod = reduce(lambda a, b: a*b, n)
    for n_i, a_i in zip(n, a):
        p = prod // n_i
        sum += a_i * mul_inv(p, n_i) * p
    return sum % prod
 
 

def mul_inv(a, b):
    b0 = b
    x0, x1 = 0, 1
    if b == 1: return 1
    while a > 1:
        q = a // b
        a, b = b, a%b
        x0, x1 = x1 - q * x0, x0
    if x1 < 0: x1 += b0
    return x1
 
print(message.decode('utf-8', errors='ignore'))

if __name__ == '__main__':
    n = [3, 5, 7]
    a = [2, 3, 2]
    print(chinese_remainder(n, a))